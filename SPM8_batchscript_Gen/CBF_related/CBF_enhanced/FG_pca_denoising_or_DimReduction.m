
function varargout=FG_pca_denoising_or_DimReduction()   
    clc
   % close all
    h_type=questdlg(sprintf('3D-img, 2D-img, or Variable?'),'Hi....','3D-img','2D-img','Variable','3D-img') ;
    h_RorC=questdlg(sprintf('Compress row or column?'),'Hi....','Row','Column','Column') ;
    
    if ~strcmp(h_type,'Variable')
        P=spm_select(1,'image', 'select an image',[],pwd);
    elseif isempty(h_type)
        return        
    else
        P=FG_varselect;
        if isempty(P), return; end
    end

%%%% threshold
    out_fix='PCA_';    
    prompt = {'Enter PCA explained Variance threshold:'};
    dlg_title = 'Hi...';
    num_lines = 1;
    def = {'0.95'};
    answer = inputdlg(prompt,dlg_title,num_lines,def);
    if FG_check_ifempty_return(answer), return; end
    PCA_threshold=str2num(answer{1});
    thres=[answer{1} '_'];
    name_RC=[h_RorC '_'];

 %%%% main procedure   
 
    if strcmp(h_type,'3D-img')        
        vtmp=spm_vol(P);
        dat=spm_read_vols(vtmp);
        dat_orign=reshape(dat,size(dat,1)*size(dat,2),size(dat,3)); % reshape the single image-value matrix into a two-Dims array
        if strcmp(h_RorC,'Column') 
            dat_col_mean=mean(dat_orign,1);
            dat_centered=dat_orign-repmat(dat_col_mean,size(dat_orign,1),1);
            covmatrix=(dat_centered'*dat_centered)/(size(dat_centered,1)-1);             
            [U,S,V]=svd(covmatrix);
            S=diag(S);totalvar=sum(S);
            for NN=1:length(S)     %  cliff, when the total variance of the first NN components is bigger than 0.95, break the searching, and record the first NN components   
                explained_Var=sum(S(1:NN))/totalvar;
                if explained_Var> PCA_threshold,break;end      
            end
            U=U(:,1:NN);V=V(:,1:NN);S=S(1:NN);S=diag(S);   % for non-ASL data, recover data directly from the first NN eigenvectors generated by SVD
            ndat=dat_centered*V; 
            ndat=ndat*V';
            imgbuf=ndat+repmat(dat_col_mean,size(dat_orign,1),1);
            imgbuf=reshape(imgbuf,[size(dat,1),size(dat,2),size(dat,3)]);             
            vtmp.fname=fullfile(spm_str_manip(vtmp.fname,'H'),[out_fix thres name_RC spm_str_manip(vtmp.fname,'ts') '.nii']);  % write the new image after PCA-denoising
            vtmp=spm_write_vol(vtmp,imgbuf);   
        elseif strcmp(h_RorC,'Row') 
            dat_row_mean=mean(dat_orign,2);
            dat_centered=dat_orign-repmat(dat_row_mean,1,size(dat_orign,2));
            covmatrix=(dat_centered'*dat_centered)/(size(dat_centered,1)-1);             
            [U,S,V]=svd(covmatrix);
            S=diag(S);totalvar=sum(S);
            for NN=1:length(S)     %  cliff, when the total variance of the first NN components is bigger than 0.95, break the searching, and record the first NN components   
                explained_Var=sum(S(1:NN))/totalvar;
                if explained_Var> PCA_threshold,break;end      
            end
            U=U(:,1:NN);V=V(:,1:NN);S=S(1:NN);S=diag(S);   % for non-ASL data, recover data directly from the first NN eigenvectors generated by SVD
            ndat=dat_centered*U; 
            ndat=ndat*U';
            imgbuf=ndat+repmat(dat_row_mean,1,size(dat_orign,2));
            imgbuf=reshape(imgbuf,[size(dat,1),size(dat,2),size(dat,3)]);               
            vtmp.fname=fullfile(spm_str_manip(vtmp.fname,'H'),[out_fix thres name_RC spm_str_manip(vtmp.fname,'ts') '.nii']);  % write the new image after PCA-denoising
            vtmp=spm_write_vol(vtmp,imgbuf);              
        end
        fprintf('\n-----PCA denoising is done!\n%s\n',vtmp.fname)
   elseif strcmp(h_type,'2D-img')  
       dat=imread(P); 
       figure('Name','original'); imshow(dat);
       if  isgray(dat) %  isa(dat,'uint8')    % gray image  
           h_img='GrayIm';
           imgbuf=FG_pca_gray_img(dat,PCA_threshold,h_img,h_RorC);
           output=FG_save_pca_gray_img(P,imgbuf,out_fix);           
           imgbuf1=FG_pca_gray_img_1(dat,PCA_threshold,h_img);           
       elseif isrgb(dat) % RGB colorful img
           h_img='RGBIm';
           for i=1:size(dat,3)
               figure('Name','Original_one_channel'); imshow(dat(:,:,i));
               imgbuf(:,:,i)=FG_pca_gray_img(dat(:,:,i),PCA_threshold,h_img,h_RorC);
               imgbuf1(:,:,i)=FG_pca_gray_img_1(dat(:,:,i),PCA_threshold,h_img);   
           end
           output=FG_save_pca_gray_img(P,imgbuf,out_fix); 
           figure('Name','FG_pca_gray_img_all'); imshow(imgbuf);
           figure('Name','FG_pca_gray_img_1_all'); imshow(imgbuf1);
       end
       fprintf('\n-----PCA denoising is done!\n%s\n',output)
    elseif strcmp(h_type,'Variable')
        if length(size(P))==2
            output=FG_pca_twoDim_var(P,PCA_threshold);
        elseif length(size(P))==3
            P=reshape(P,size(P,1)*size(P,2),size(P,3));
            output=FG_pca_twoDim_var(P,PCA_threshold);
            output=reshape(output,size(P));
        end
    end

    if nargout==1
        varargout={output};
    end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%% sub functions  %%%%%%
    function imgbuf=FG_pca_gray_img(dat,PCA_threshold,h_img,h_RorC)  % svd(covariance_matrix)
          dat_orign=double(dat);
          %%% option 1, compress column; calculate the mean of each column,
          %%% use V in [U,S,V]=svd(covmatrix) to reconstruct the image
          if strcmp(h_RorC,'Column')     
                dat_col_mean=mean(dat_orign,1);
                dat_centered=dat_orign-repmat(dat_col_mean,size(dat_orign,1),1);
                covmatrix=(dat_centered'*dat_centered)/(size(dat_centered,1)-1); 
                [U,S,V]=svd(covmatrix);
                S=diag(S); % original : S=diag(S)
        %             S=S.*S;
                totalvar=sum(S);  
               % figure('name','variance-bar');        tem=S.*S;  bar(S(1:50,:))
                for NN=1:length(S)     %  cliff, when the total variance of the first NN components is bigger than 0.95, break the searching, and record the first NN components   
                    explained_Var=sum(S(1:NN))/totalvar;
                    if explained_Var> PCA_threshold,break;end      
                end
                U=U(:,1:NN);V=V(:,1:NN);S=S(1:NN);S=diag(S);   % for non-ADSL data, recover data directly from the first NN eigenvectors generated by SVD
              %% option 1
        %         finaldat=V'*dat_centered';
        %         ndat=finaldat'*U';
              %% option 2
        %           finaldat=dat_centered*U;
        %           ndat=finaldat*V';   
              %% option 3   --- 
        %           finaldat=dat_centered*U;
        %           ndat=finaldat*U';   
              %% option 4
                finaldat=V'*dat_centered';
                ndat=finaldat'*V';          
                ndat=ndat+repmat(dat_col_mean,size(dat_orign,1),1);
                imgbuf=mat2gray(ndat);         
         %%% option 2, compress row; calculate the mean of each row,
         %%% use U in [U,S,V]=svd(covmatrix) to reconstruct the image
          elseif strcmp(h_RorC,'Row')   
                dat_row_mean=mean(dat_orign,2);
                dat_centered=dat_orign-repmat(dat_row_mean,1,size(dat_orign,2));
                covmatrix=(dat_centered*dat_centered')/(size(dat_centered',1)-1); 
                [U,S,V]=svd(covmatrix);
                S=diag(S); % original : S=diag(S)
        %             S=S.*S;
                totalvar=sum(S);  
               % figure('name','variance-bar');        tem=S.*S;  bar(S(1:50,:))
                for NN=1:length(S)     %  cliff, when the total variance of the first NN components is bigger than 0.95, break the searching, and record the first NN components   
                    explained_Var=sum(S(1:NN))/totalvar;
                    if explained_Var> PCA_threshold,break;end      
                end
                U=U(:,1:NN);V=V(:,1:NN);S=S(1:NN);S=diag(S);   % for non-ADSL data, recover data directly from the first NN eigenvectors generated by SVD
              %% option 3   --- 
                finaldat=U'*dat_centered;
                ndat=U*finaldat;  
                ndat=ndat+repmat(dat_row_mean,1,size(dat_orign,2));
                imgbuf=mat2gray(ndat);                  
          end
          if strcmp(h_img,'GrayIm')  
             figure('Name','FG_pca_gray_img'); imshow(imgbuf);
          end
          

       
        
    function imgbuf=FG_pca_gray_img_1(dat,PCA_threshold,h_img)  % svd(original_matrix)
        dat_orign=double(dat);
        [U,S,V]=svd(dat_orign);
        S=diag(S);
        totalvar=sum(S);  
        for NN=1:length(S)     %  cliff, when the total variance of the first NN components is bigger than 0.95, break the searching, and record the first NN components   
            explained_Var=sum(S(1:NN))/totalvar;
            if explained_Var> PCA_threshold,break;end      
        end
        U=U(:,1:NN);V=V(:,1:NN);S=S(1:NN);S=diag(S);   % for non-ADSL data, recover data directly from the first NN eigenvectors generated by SVD
        ndat=U*S*V';
        imgbuf=uint8(ndat);   
        if strcmp(h_img,'GrayIm') 
            figure('Name','FG_pca_gray_img_1'); imshow(imgbuf);
        end
        
        
        
            
    function output=FG_save_pca_gray_img(P,imgbuf,out_fix,thres)
        [a,b,c,d]=fileparts(P);
        output=fullfile(a,[out_fix thres name_RC b c]);
        imwrite(imgbuf,output,c(2:end));  % write the new image after PCA-denoising
        
    function output=FG_pca_twoDim_var(P,PCA_threshold)
        dat_orign=P;
%         dat_col_mean=mean(dat_orign,1);
%         dat_centered=dat_orign-repmat(dat_col_mean,size(dat_orign,1),1);
%         covmatrix=(dat_centered'*dat_centered)/(size(dat_centered,1)-1); 
%         [U,S,V]=svd(covmatrix);
        [U,S,V]=svd(dat_orign);
        S=diag(S);
        totalvar=sum(S);  
        for NN=1:length(S)     %  cliff, when the total variance of the first NN components is bigger than 0.95, break the searching, and record the first NN components   
            explained_Var=sum(S(1:NN))/totalvar;
            if explained_Var> PCA_threshold,break;end      
        end
        U=U(:,1:NN);V=V(:,1:NN);S=S(1:NN);S=diag(S);   % for non-ADSL data, recover data directly from the first NN eigenvectors generated by SVD
        output=U*S*V';
        sprintf(['\n-----PCA dimention-reduction is done!\n'])

    
    