
function fileout=FG_pca_for_artifact_2(imgs,sub_dir,PCA_threshold)    
if nargin==0
        imgs = spm_select(inf,'any','Select imgs to do PCA', [],pwd,'.*img$|.*nii$');  
        if FG_check_ifempty_return(imgs), return;end
        [a,b,c,d]=fileparts(imgs(1,:));
        sub_dir=a;
        cd (a)       
        
         prompt={'Enter the explained variance you want to keep in PCA:'};
         name='Hi...';
         numlines=1;
         def_ans={'0.95'};         
         answ=inputdlg(prompt,name,numlines,def_ans);
         PCA_threshold=str2num(answ{1});         
end

    thres=[num2str(PCA_threshold) '_'];
    P=imgs;
    out_fix='pca_';
    mask_name='EPI_mask_for_motion_filter.nii';
    
     % optional: cliff, do deal with only one input img
     if size(P,1)==1  
        vtmp=spm_vol(P);
        dat_orign=spm_read_vols(vtmp);
        dat=reshape(dat_orign,size(dat_orign,1)*size(dat_orign,2),size(dat_orign,3)); % reshape the single image-value matrix into a two-Dims array
   %%%%%%%% option 1
%         [U,S,V]=svd(dat);
%         S=diag(S);totalvar=sum(S);
%         for NN=1:length(S)     %  cliff, when the total variance of the first NN components is bigger than 0.95, break the searching, and record the first NN components   
%             explained_Var=sum(S(1:NN))/totalvar;
%             if explained_Var> PCA_threshold,break;end      
%         end
%         U=U(:,1:NN);V=V(:,1:NN);S=S(1:NN);S=diag(S);   % for non-ASL data, recover data directly from the first NN eigenvectors generated by SVD
%         ndat=U*S*V';        
%         imgbuf=reshape(ndat,[size(dat_orign,1),size(dat_orign,2),size(dat_orign,3)]);   
%         vtmp.fname=fullfile(spm_str_manip(vtmp.fname,'H'),[out_fix spm_str_manip(vtmp.fname,'ts') '.nii']);  % write the new image after PCA-denoising
%         vtmp=spm_write_vol(vtmp,imgbuf);   
   %%%%%%%% option 2      
            dat_col_mean=mean(dat,1);
            dat_centered=dat-repmat(dat_col_mean,size(dat_orign,1)*size(dat_orign,2),1);
            covmatrix=(dat_centered'*dat_centered)/(size(dat_centered,1)-1); 
            [U,S,V]=svd(covmatrix);
            S=diag(S);
            totalvar=sum(S);  
            for NN=1:length(S)     %  cliff, when the total variance of the first NN components is bigger than 0.95, break the searching, and record the first NN components   
                explained_Var=sum(S(1:NN))/totalvar;
                if explained_Var> PCA_threshold,break;end      
            end
            U=U(:,1:NN);V=V(:,1:NN);S=S(1:NN);S=diag(S);   % for non-ASL data, recover data directly from the first NN eigenvectors generated by SVD
            finaldat=dat_centered*V;
            ndat=finaldat*V';
            ndat=ndat+repmat(dat_col_mean,size(dat_orign,1)*size(dat_orign,2),1);
            imgbuf=reshape(ndat,[size(dat_orign,1),size(dat_orign,2),size(dat_orign,3)]);   
            vtmp.fname=fullfile(spm_str_manip(vtmp.fname,'H'),[out_fix thres spm_str_manip(vtmp.fname,'ts') '.nii']);  % write the new image after PCA-denoising
            vtmp=spm_write_vol(vtmp,imgbuf); 
     %%%%%   
        
        fprintf('\n-----PCA reconstruction is done!\n')
        return
     end 
     

    % P=strvcat(P,spm_select('FPList',PAR.subs(sb).ses(nse).condirs{c},['^fltraw.*.nii']));
    N_imgs=size(P,1);

    

   %% make a EPI mask   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     maskfile=[];
%     idx=[];    
%     idxsign=[-1 1];
%     datsum=0;

    maskfile=fullfile(sub_dir,mask_name);   % reuse the mask img generated in motion-filter
    vm=spm_vol(maskfile);
    mask=spm_read_vols(vm);
    mask=mask>0;   % binarize the mask into a logical matrix
    indices=find(mask>0);  % find out the ROI regions within the mask
    
    vtmp=spm_vol(P);
    dat=spm_read_vols(vtmp);
    dat=reshape(dat,size(dat,1)*size(dat,2)*size(dat,3),size(dat,4)); % reshape the image-value matrix into a two-Dims array

% mask the image
    dat_masked=dat(indices,:);  % Be careful: this will filter the "dat" matrix at each column, dat=dat(idx) will only apply the filter at the first column
    dat_masked(find(isnan(dat_masked)))=1e-7;  % set the Nan values into 0.0000001 which is the infinitesimal(infinity small)    
    
%%%% start the PCA procedure, first, get the mean of each voxel across imgs    
% get the covariance matrix of the imgs
   % first: get the mean of each voxel across imgs
    mean_of_each_voxel_across_imgs=mean(dat_masked,2);    
   % second, decentralize each voxel-value with corresponding column-mean
    dat_centered=dat_masked-repmat(mean_of_each_voxel_across_imgs,1,size(dat_masked,2));    
   % third, get the covariance matrix
    covmatrix=(dat_centered'*dat_centered)/(size(dat_centered,1)-1);  
    
    % actually, in Matlab, you can use cov(dat_masked) to get the same value as covmatrix= dat_centered'*dat_centered/size(dat_centered',1)
    % but in PCA, we need to use some output of the decentralization to
    % reconstrcute the original image, so we had better to calculate the
    % covariance matrix step by step as above.
    %%%%%%%%
  
     
 %% the following 3 lines are same as in the function "pcacov.m"   
    [U,S,V]=svd(covmatrix);   % Singular value decomposition of the covariance, [U,S,V] = svd(covar);
    % U and V are the unitary matrix
    S=diag(S); %  get each principal component variances into a vector
    totalvar=sum(S); % total variance    
%     PCA_threshold=0.95;   %  explained variance threshold: 95%
    
    for NN=1:N_imgs     %  cliff, when the total variance of the first NN components is bigger than 0.95, break the searching, and record the first NN components   
        explained_Var=sum(S(1:NN))/totalvar;
        if explained_Var> PCA_threshold,break;end   
    end
    
 %%%%%%%%  traditional PCA is over, you can use (U1+mean_of_each_voxel_across_imgs) to recover the image after PCA %%%%%%%%%%%%%%%
 %%%% but this means you will reduce voxle numbers of each image %%%%%%%%%
 %%%% now we need to keep all the voxels while setting the value of the voxels that should be excluded into 0 %%%%%%%%%%%%%%%%%%%%%
 

      U=U(:,1:NN);V=V(:,1:NN);S=S(1:NN);S=diag(S);   % for non-ASL data, recover data directly from the first NN eigenvectors generated by SVD
      finaldat=dat_centered*U;
      ndat=finaldat*S*V';      

 
  
  %%%%%%%%  then "ndat" is used to recover the noise-reduced image with "mean_of_each_voxel_across_imgs"  %%%%%%%%%%
    for im=1:N_imgs
        imgbuf=zeros(vtmp(im).dim(1),vtmp(im).dim(2),vtmp(im).dim(3));
        imgbuf(indices)=mean_of_each_voxel_across_imgs+ndat(:,im);  % recover the noise-reduced image
        vtmp(im).fname=fullfile(spm_str_manip(vtmp(im).fname,'H'),[out_fix thres spm_str_manip(vtmp(im).fname,'ts') '.nii']);  % write the new image after PCA-denoising
        vtmp(im)=spm_write_vol(vtmp(im),imgbuf);
    end

    [a,b,c,fileout]=FG_separate_files_into_name_and_path(imgs,[out_fix thres],'prefix','.nii');
    
    fprintf('\n-----PCA reconstruction is done!\n')
    
 
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    