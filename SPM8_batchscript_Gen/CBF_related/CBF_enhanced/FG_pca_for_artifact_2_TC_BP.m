
function fileout=FG_pca_for_artifact_2_TC_BP(imgs,sub_dir,PCA_threshold)    
if nargin==0
        imgs = spm_select(inf,'any','Select imgs to do PCA', [],pwd,'.*img$|.*nii$');  
        if FG_check_ifempty_return(imgs), return;end
        [a,b,c,d]=fileparts(imgs(1,:));
        sub_dir=a;
        cd (a)       
        
%          prompt={'Enter the explained variance you want to keep in PCA:'};
%          name='Hi...';
%          numlines=1;
%          def_ans={'0.95'};         
%          answ=inputdlg(prompt,name,numlines,def_ans);
%          PCA_threshold=str2num(answ{1});         
end
    close all
    Imat=spm_vol(imgs);
    Ivol=spm_read_vols(Imat);  % 4D volumes
    [x,y,z,T]=size(Ivol)
    figure;
    subplot(3,1,1);
    imshow(Ivol(:,:,10,4),[])
   % crop out (select) the front/back part(1/3 y-axis) of the brain to reduce
   % data, because we are clear about the location of the potential artifact
   
   % back 1/3
   Ivol1=Ivol(:,1:y*1/3,:,:);
   [x,y1,z,T]=size(Ivol1);
   subplot(3,1,2);
   imshow(Ivol1(:,:,10,4),[])
   % front 1/3
    Ivol2=Ivol(:,y*2/3:y,:,:);
    [x,y2,z,T]=size(Ivol2);
    subplot(3,1,3);
    imshow(Ivol2(:,:,10,4),[])
    
    V=reshape(Ivol2,[x*y2*z,T]);
    % remove all the zero voxels
    tem=[];
    for i=1:x*y2*z
        if isempty(find(V(i,:)~=0))
            tem=[tem, i];
        end
    end
    V_new=V;
    V_new(tem,:)=[];
    
  %% pca
  [coeff,score]=princomp(V_new);
  back_img=score*coeff;
  figure; plot(1:80,back_img(1:end,:))
    
    
    
    
    
    
 
  %% least variance & largest mean of timecourse

  Means=mean(V_new')';
  Stds=std(V_new')';
  Mean_filter=5*std(Means);
  Std_filter=5*mean(Stds);  
  
  mean_voxs=find(Means>Mean_filter);
  std_voxs=find(Stds>Std_filter);
  if length(mean_voxs)>length(std_voxs)
      found=ismember(std_voxs,mean_voxs)  ;
  elseif length(std_voxs)>length(mean_voxs)
      found=ismember(mean_voxs,std_voxs);
  end
   
  a=std_voxs(found(found==1));
  potential_voxs_TC=V_new(a,:);
  figure; plot(1:size(potential_voxs_TC,2),potential_voxs_TC)
  figure; plot(1:size(V_new,2),V_new)
  [Rs,Ps]=corrcoef(potential_voxs_TC');
  Rs_of_Artifact_ROIs=FG_set_half_diagonal_matrix_into_n(Rs,0,'below');
  FG_show_correlation_matrix(Rs_of_Artifact_ROIs);
  [a,b]=find(Rs_of_Artifact_ROIs>0.95); %% do we need to constrain their should be not less than 2 pairs?
    if isempty(a)
        fprintf('\n---- Correlations between Artifact ROIs are low. That indicated no need to care about the artifact...\n')
    else
        selected_ROIs=unique([a;b]');
        fprintf('\n---- No. %s ROIs''s timecourse were selected and averaged as the representive artifact timecouse ...\n',num2str(selected_ROIs))
        selected_TCs=potential_voxs_TC(selected_ROIs',:);
        figure; plot(1:size(selected_TCs,2),selected_TCs)
        artifact_TC=mean( selected_TCs,1);
    end   
  
  
    %% pca method 
    [coeff,sc,latent]=princomp(V_new);
    figure; plot(coeff(:,1:10))
%     [coeff,sc,latent]=princomp(V_new');
%     figure; plot(coeff(:,1:10))   




    
    thres=[num2str(PCA_threshold) '_'];
    P=imgs;
    out_fix='pca_';
    mask_name='EPI_mask_for_motion_filter.nii';
    
     % optional: cliff, do deal with only one input img
     if size(P,1)==1  
        vtmp=spm_vol(P);
        dat_orign=spm_read_vols(vtmp);
        dat=reshape(dat_orign,size(dat_orign,1)*size(dat_orign,2),size(dat_orign,3)); % reshape the single image-value matrix into a two-Dims array
   %%%%%%%% option 1
%         [U,S,V]=svd(dat);
%         S=diag(S);totalvar=sum(S);
%         for NN=1:length(S)     %  cliff, when the total variance of the first NN components is bigger than 0.95, break the searching, and record the first NN components   
%             explained_Var=sum(S(1:NN))/totalvar;
%             if explained_Var> PCA_threshold,break;end      
%         end
%         U=U(:,1:NN);V=V(:,1:NN);S=S(1:NN);S=diag(S);   % for non-ASL data, recover data directly from the first NN eigenvectors generated by SVD
%         ndat=U*S*V';        
%         imgbuf=reshape(ndat,[size(dat_orign,1),size(dat_orign,2),size(dat_orign,3)]);   
%         vtmp.fname=fullfile(spm_str_manip(vtmp.fname,'H'),[out_fix spm_str_manip(vtmp.fname,'ts') '.nii']);  % write the new image after PCA-denoising
%         vtmp=spm_write_vol(vtmp,imgbuf);   
   %%%%%%%% option 2      
            dat_col_mean=mean(dat,1);
            dat_centered=dat-repmat(dat_col_mean,size(dat_orign,1)*size(dat_orign,2),1);
            covmatrix=(dat_centered'*dat_centered)/(size(dat_centered,1)-1); 
            [U,S,V]=svd(covmatrix);
            S=diag(S);
            totalvar=sum(S);  
            for NN=1:length(S)     %  cliff, when the total variance of the first NN components is bigger than 0.95, break the searching, and record the first NN components   
                explained_Var=sum(S(1:NN))/totalvar;
                if explained_Var> PCA_threshold,break;end      
            end
            U=U(:,1:NN);V=V(:,1:NN);S=S(1:NN);S=diag(S);   % for non-ASL data, recover data directly from the first NN eigenvectors generated by SVD
            finaldat=dat_centered*V;
            ndat=finaldat*V';
            ndat=ndat+repmat(dat_col_mean,size(dat_orign,1)*size(dat_orign,2),1);
            imgbuf=reshape(ndat,[size(dat_orign,1),size(dat_orign,2),size(dat_orign,3)]);   
            vtmp.fname=fullfile(spm_str_manip(vtmp.fname,'H'),[out_fix thres spm_str_manip(vtmp.fname,'ts') '.nii']);  % write the new image after PCA-denoising
            vtmp=spm_write_vol(vtmp,imgbuf); 
     %%%%%   
        
        fprintf('\n-----PCA reconstruction is done!\n')
        return
     end 
     

    % P=strvcat(P,spm_select('FPList',PAR.subs(sb).ses(nse).condirs{c},['^fltraw.*.nii']));
    N_imgs=size(P,1);

    

   %% make a EPI mask   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     maskfile=[];
%     idx=[];    
%     idxsign=[-1 1];
%     datsum=0;

    maskfile=fullfile(sub_dir,mask_name);   % reuse the mask img generated in motion-filter
    vm=spm_vol(maskfile);
    mask=spm_read_vols(vm);
    mask=mask>0;   % binarize the mask into a logical matrix
    indices=find(mask>0);  % find out the ROI regions within the mask
    
    vtmp=spm_vol(P);
    dat=spm_read_vols(vtmp);
    dat=reshape(dat,size(dat,1)*size(dat,2)*size(dat,3),size(dat,4)); % reshape the image-value matrix into a two-Dims array

% mask the image
    dat_masked=dat(indices,:);  % Be careful: this will filter the "dat" matrix at each column, dat=dat(idx) will only apply the filter at the first column
    dat_masked(find(isnan(dat_masked)))=1e-7;  % set the Nan values into 0.0000001 which is the infinitesimal(infinity small)    
    
%%%% start the PCA procedure, first, get the mean of each voxel across imgs    
% get the covariance matrix of the imgs
   % first: get the mean of each voxel across imgs
    mean_of_each_voxel_across_imgs=mean(dat_masked,2);    
   % second, decentralize each voxel-value with corresponding column-mean
    dat_centered=dat_masked-repmat(mean_of_each_voxel_across_imgs,1,size(dat_masked,2));    
   % third, get the covariance matrix
    covmatrix=(dat_centered'*dat_centered)/(size(dat_centered,1)-1);  
    
    % actually, in Matlab, you can use cov(dat_masked) to get the same value as covmatrix= dat_centered'*dat_centered/size(dat_centered',1)
    % but in PCA, we need to use some output of the decentralization to
    % reconstrcute the original image, so we had better to calculate the
    % covariance matrix step by step as above.
    %%%%%%%%
  
     
 %% the following 3 lines are same as in the function "pcacov.m"   
    [U,S,V]=svd(covmatrix);   % Singular value decomposition of the covariance, [U,S,V] = svd(covar);
    % U and V are the unitary matrix
    S=diag(S); %  get each principal component variances into a vector
    totalvar=sum(S); % total variance    
%     PCA_threshold=0.95;   %  explained variance threshold: 95%
    
    for NN=1:N_imgs     %  cliff, when the total variance of the first NN components is bigger than 0.95, break the searching, and record the first NN components   
        explained_Var=sum(S(1:NN))/totalvar;
        if explained_Var> PCA_threshold,break;end   
    end
    
 %%%%%%%%  traditional PCA is over, you can use (U1+mean_of_each_voxel_across_imgs) to recover the image after PCA %%%%%%%%%%%%%%%
 %%%% but this means you will reduce voxle numbers of each image %%%%%%%%%
 %%%% now we need to keep all the voxels while setting the value of the voxels that should be excluded into 0 %%%%%%%%%%%%%%%%%%%%%
 

      U=U(:,1:NN);V=V(:,1:NN);S=S(1:NN);S=diag(S);   % for non-ASL data, recover data directly from the first NN eigenvectors generated by SVD
      finaldat=dat_centered*U;
      ndat=finaldat*S*V';      

 
  
  %%%%%%%%  then "ndat" is used to recover the noise-reduced image with "mean_of_each_voxel_across_imgs"  %%%%%%%%%%
    for im=1:N_imgs
        imgbuf=zeros(vtmp(im).dim(1),vtmp(im).dim(2),vtmp(im).dim(3));
        imgbuf(indices)=mean_of_each_voxel_across_imgs+ndat(:,im);  % recover the noise-reduced image
        vtmp(im).fname=fullfile(spm_str_manip(vtmp(im).fname,'H'),[out_fix thres spm_str_manip(vtmp(im).fname,'ts') '.nii']);  % write the new image after PCA-denoising
        vtmp(im)=spm_write_vol(vtmp(im),imgbuf);
    end

    [a,b,c,fileout]=FG_separate_files_into_name_and_path(imgs,[out_fix thres],'prefix','.nii');
    
    fprintf('\n-----PCA reconstruction is done!\n')
    
 
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    