
function fileout=FG_pca_denoising_after_motion_filter(files_after_motion_filter,sub_dir,PCA_threshold,ASLorNo)    
    if nargin ==0
        files_after_motion_filter = spm_select(inf,'any','Select imgs to do PCA', [],pwd,'.*img$|.*nii$');  
        if FG_check_ifempty_return(files_after_motion_filter), return;end
        [a,b,c,d]=fileparts(files_after_motion_filter(1,:));
        sub_dir=a;
        cd (a)       
        
         prompt={'Enter the explained variance you want to keep in PCA:'};
         name='Hi...';
         numlines=1;
         def_ans={'0.95'};         
         answ=inputdlg(prompt,name,numlines,def_ans);
         PCA_threshold=str2num(answ{1});
         thres=[answ{1} '_'];
        ASLorNo=questdlg(sprintf('Is the data for ASL-CBF preprocessing? \n If not or the data is just a simple dataset that is not in preprocessing, \n please click No'),'Hi....','CBF','No','CBF') ;
        if isempty(ASLorNo), return; end;    % for ASL data, do one more eigenvector filtering before recovering data 
    elseif nargin ==1
        [a,b,c,d]=fileparts(files_after_motion_filter(1,:));
        sub_dir=a;
        cd (a)
        
         prompt={'Enter the explained variance you want to keep in PCA:'};
         name='Hi...';
         numlines=1;
         def_ans={'0.95'};         
         answ=inputdlg(prompt,name,numlines,def_ans);
         PCA_threshold=str2num(answ{1});
         thres=[answ{1} '_'];
        ASLorNo=questdlg(sprintf('Is the data for ASL-CBF preprocessing? \n If not or the data is just a simple dataset that is not in preprocessing, \n please click No'),'Hi....','CBF','No','CBF') ;
        if isempty(ASLorNo), return; end;
    elseif nargin ==2
        cd (sub_dir)

         prompt={'Enter the explained variance you want to keep in PCA:'};
         name='Hi...';
         numlines=1;
         def_ans={'0.95'};         
         answ=inputdlg(prompt,name,numlines,def_ans);
         PCA_threshold=str2num(answ{1});
        thres=[answ{1} '_'];
        ASLorNo=questdlg(sprintf('Is the data for ASL-CBF preprocessing? \n If not or the data is just a simple dataset that is not in preprocessing, \n please click No'),'Hi....','CBF','No','CBF') ;
        if isempty(ASLorNo), return; end;
    elseif nargin ==3
        cd (sub_dir)
        thres=[num2str(PCA_threshold) '_'];
        ASLorNo=questdlg(sprintf('Is the data for ASL-CBF preprocessing? \n If not or the data is just a simple dataset that is not in preprocessing, \n please click No'),'Hi....','CBF','No','CBF') ;
        if isempty(ASLorNo), return; end;
    elseif nargin ==4
        cd (sub_dir)
        thres=[num2str(PCA_threshold) '_'];
    end
    
    P=files_after_motion_filter;
    out_fix='pca_';
    mask_name='EPI_mask_for_motion_filter.nii';
    
%      if size(P,1)==1  
%         sprintf('\n----\nYou only select 1 img to do the PCA! \nThe result will be same as the original one in this script! \nPlease select at least 2 imgs!\n') % Usually,return when there is only one
%         return                     %     img uder subj's folder. but actually, SCD and PCA can deal with only
%      end                           %     one image
%      
     
     % optional: cliff, do deal with only one input img
     if size(P,1)==1  
        vtmp=spm_vol(P);
        dat_orign=spm_read_vols(vtmp);
        dat=reshape(dat_orign,size(dat_orign,1)*size(dat_orign,2),size(dat_orign,3)); % reshape the single image-value matrix into a two-Dims array
   %%%%%%%% option 1
%         [U,S,V]=svd(dat);
%         S=diag(S);totalvar=sum(S);
%         for NN=1:length(S)     %  cliff, when the total variance of the first NN components is bigger than 0.95, break the searching, and record the first NN components   
%             explained_Var=sum(S(1:NN))/totalvar;
%             if explained_Var> PCA_threshold,break;end      
%         end
%         U=U(:,1:NN);V=V(:,1:NN);S=S(1:NN);S=diag(S);   % for non-ASL data, recover data directly from the first NN eigenvectors generated by SVD
%         ndat=U*S*V';        
%         imgbuf=reshape(ndat,[size(dat_orign,1),size(dat_orign,2),size(dat_orign,3)]);   
%         vtmp.fname=fullfile(spm_str_manip(vtmp.fname,'H'),[out_fix spm_str_manip(vtmp.fname,'ts') '.nii']);  % write the new image after PCA-denoising
%         vtmp=spm_write_vol(vtmp,imgbuf);   
   %%%%%%%% option 2      
            dat_col_mean=mean(dat,1);
            dat_centered=dat-repmat(dat_col_mean,size(dat_orign,1)*size(dat_orign,2),1);
            covmatrix=(dat_centered'*dat_centered)/(size(dat_centered,1)-1); 
            [U,S,V]=svd(covmatrix);
            S=diag(S);
            totalvar=sum(S);  
            for NN=1:length(S)     %  cliff, when the total variance of the first NN components is bigger than 0.95, break the searching, and record the first NN components   
                explained_Var=sum(S(1:NN))/totalvar;
                if explained_Var> PCA_threshold,break;end      
            end
            U=U(:,1:NN);V=V(:,1:NN);S=S(1:NN);S=diag(S);   % for non-ASL data, recover data directly from the first NN eigenvectors generated by SVD
            finaldat=dat_centered*V;
            ndat=finaldat*V';
            ndat=ndat+repmat(dat_col_mean,size(dat_orign,1)*size(dat_orign,2),1);
            imgbuf=reshape(ndat,[size(dat_orign,1),size(dat_orign,2),size(dat_orign,3)]);   
            vtmp.fname=fullfile(spm_str_manip(vtmp.fname,'H'),[out_fix thres spm_str_manip(vtmp.fname,'ts') '.nii']);  % write the new image after PCA-denoising
            vtmp=spm_write_vol(vtmp,imgbuf); 
     %%%%%   
        
        fprintf('\n-----PCA reconstruction is done!\n')
        return
     end 
     

    % P=strvcat(P,spm_select('FPList',PAR.subs(sb).ses(nse).condirs{c},['^fltraw.*.nii']));
    N_imgs=size(P,1);

    

   %% make a EPI mask   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     maskfile=[];
%     idx=[];    
%     idxsign=[-1 1];
%     datsum=0;

    maskfile=fullfile(sub_dir,mask_name);   % reuse the mask img generated in motion-filter
    vm=spm_vol(maskfile);
    mask=spm_read_vols(vm);
    mask=mask>0;   % binarize the mask into a logical matrix
    indices=find(mask>0);  % find out the ROI regions within the mask
    
    vtmp=spm_vol(P);
    dat=spm_read_vols(vtmp);
    dat=reshape(dat,size(dat,1)*size(dat,2)*size(dat,3),size(dat,4)); % reshape the image-value matrix into a two-Dims array

% mask the image
    dat_masked=dat(indices,:);  % Be careful: this will filter the "dat" matrix at each column, dat=dat(idx) will only apply the filter at the first column
    dat_masked(find(isnan(dat_masked)))=1e-7;  % set the Nan values into 0.0000001 which is the infinitesimal(infinity small)    
    
%%%% start the PCA procedure, first, get the mean of each voxel across imgs    
% get the covariance matrix of the imgs
   % first: get the mean of each voxel across imgs
    mean_of_each_voxel_across_imgs=mean(dat_masked,2);    
   % second, decentralize each voxel-value with corresponding column-mean
    dat_centered=dat_masked-repmat(mean_of_each_voxel_across_imgs,1,size(dat_masked,2));    
   % third, get the covariance matrix
    covmatrix=(dat_centered'*dat_centered)/(size(dat_centered,1)-1);  
    
    % actually, in Matlab, you can use cov(dat_masked) to get the same value as covmatrix= dat_centered'*dat_centered/size(dat_centered',1)
    % but in PCA, we need to use some output of the decentralization to
    % reconstrcute the original image, so we had better to calculate the
    % covariance matrix step by step as above.
    %%%%%%%%
  
     
 %% the following 3 lines are same as in the function "pcacov.m"   
    [U,S,V]=svd(covmatrix);   % Singular value decomposition of the covariance, [U,S,V] = svd(covar);
    % U and V are the unitary matrix
    S=diag(S); %  get each principal component variances into a vector
    totalvar=sum(S); % total variance    
%     PCA_threshold=0.95;   %  explained variance threshold: 95%
    
    for NN=1:N_imgs     %  cliff, when the total variance of the first NN components is bigger than 0.95, break the searching, and record the first NN components   
        explained_Var=sum(S(1:NN))/totalvar;
        if explained_Var> PCA_threshold,break;end   
    end
    
 %%%%%%%%  traditional PCA is over, you can use (U1+mean_of_each_voxel_across_imgs) to recover the image after PCA %%%%%%%%%%%%%%%
 %%%% but this means you will reduce voxle numbers of each image %%%%%%%%%
 %%%% now we need to keep all the voxels while setting the value of the voxels that should be excluded into 0 %%%%%%%%%%%%%%%%%%%%%
 
 
 if strcmpi(ASLorNo,'CBF')  % for ASL data, do one more eigenvector filtering before recovering data 
 
 %%%%%%  below is an extra feature-Eigenvector filtering procedure, this is specially for the ASL label-control dataset  %%%%%%%%%%  
     %%%
        U1=dat_centered*U;  % project dat_centered onto U-eigenvectors, U1 is the projected-dat_centered
        for i=1:size(U1,2)
            U1(:,i)=U1(:,i)/norm(U1(:,i));    % NORM(X) is the largest singular value of X, max(svd(X))
        end    % The original author said that this is used to standize the U1 score . ----------  this make U1 is a relative-weight matrix
  
        coef=dat_centered'*U1;  % coefficient
    
     % read the rp*.txt parameters
        movefil = spm_select('FPList',sub_dir, ['^rp_' '\w*.*.txt']); % read and load the rp*.txt file which contains the motion parameters
        if size(movefil,1)>1,
            fprintf('\nI can decide which rp*.txt file to use!\n')
            h_GOnoGo=questdlg(sprintf(['If you want to continue,the first file: \n' ,movefil(1,:) ,'\nwill be used!']),'Hi....','Yes','No','Yes') ;
            if strcmp(h_GOnoGo,'Yes')
               fprintf('\nLet''s go ahead!\n')
            else
               return
            end
        elseif size(movefil,1)==0,
            fprintf('\nI can''t find a rp*.txt file to use!\n')
            return
        end   % return when there are no rp*.txt file
        movefil=deblank(movefil(1,:));
        moves = spm_load(movefil);
        moves=moves(1:N_imgs,:);
        moves(:,4:6)=moves(:,4:6)*180/pi;  % just for the last 4-6 columns (rotation) of the motion parameters, change its unit into "degree"
        moves=moves(1:size(P,1),:);   % take use of the motion_papameters    
 
    NU=[];NV=[];NS=[]; 
    ncoef=[];

    tagctr=-ones(N_imgs,1);
    tagctr(2:2:end)=1;
%      refs=FG_cgrscho_orthogonalization(refs);
    
    beta=tagctr\moves; %% assume:  moves= tagctr* beta + error, first, use non-error regression (tagctr*beta=moves) ==> (beta = tagctr\moves) to get (beta),                          
    moves=moves-tagctr*beta;  %  then (moves-tagctr*beta) is the residual of the moves that exclude the influence of tagctr variable (label-control)         

    %% further feature-Eigenvector filtering procedure
            for i=1:NN   % for the first NN images, if it is correlated with the motion-prara smaller than 0.1 (means no correlation), it will be kept, otherwise it will be delete
                %% [cr,cp]=corrcoef(U(:,i),tagctr);
                [cr2]=corr(U(:,i),moves);
            %         if abs(cp(1,2))<0.5&&any(cr2<0.1)
                if any(cr2<0.1)
                    NU=[NU U1(:,i)];
            %             NV=[NV V(:,i)];
                    NS=[NS S(i)];
                    ncoef=[ncoef coef(:,i)];
                end
            end

            for i=(NN+1):N_imgs   % for the last (NN-N_imgs) images, if it is correlated with ref (label-control) variable, and no correlated with motion-para (coeff<0.05), it will be kept
                [cr,cp]=corrcoef(U(:,i),tagctr);  % be careful: use U to do correlation, but select U1 as the output
                [cr2]=corr(U(:,i),moves);
                if abs(cp(1,2))<0.01&&any(cr2<0.05)
                    NU=[NU U1(:,i)];
            %             NV=[NV V(:,i)];
                    NS=[NS S(i)];
                    ncoef=[ncoef coef(:,i)];
                end
            end
    %% data recovery %%%
        ncoef=ncoef';
        ndat=NU*ncoef;      
    %%%  further data cleaning is done %%%
 else
      U=U(:,1:NN);V=V(:,1:NN);S=S(1:NN);S=diag(S);   % for non-ASL data, recover data directly from the first NN eigenvectors generated by SVD
      finaldat=dat_centered*U;
      ndat=finaldat*S*V';      
 end
 
  
  %%%%%%%%  then "ndat" is used to recover the noise-reduced image with "mean_of_each_voxel_across_imgs"  %%%%%%%%%%
    for im=1:N_imgs
        imgbuf=zeros(vtmp(im).dim(1),vtmp(im).dim(2),vtmp(im).dim(3));
        imgbuf(indices)=mean_of_each_voxel_across_imgs+ndat(:,im);  % recover the noise-reduced image
        vtmp(im).fname=fullfile(spm_str_manip(vtmp(im).fname,'H'),[out_fix thres spm_str_manip(vtmp(im).fname,'ts') '.nii']);  % write the new image after PCA-denoising
        vtmp(im)=spm_write_vol(vtmp(im),imgbuf);
    end

    [a,b,c,fileout]=FG_separate_files_into_name_and_path(files_after_motion_filter,[out_fix thres],'prefix','.nii');
    
    fprintf('\n-----PCA reconstruction is done!\n')
    
    